---
title: 分布式一致性
date: 2017-12-25 15:12:06
tags:
	- 分布式
---

为了保证数据的高可用性，通常会在不同物理节点上保存多个副本。而为了保证对用户提供统一、正确的增删改查等语义，需要保证不同物理机器上的副本是一致的。

## 1. 分布式事务
单个节点上的数据操作可以满足ACID，但是相互独立的节点无法知道对方的事务执行情况。如果要保证数据的一致性，就必须对数据写操作要求其能够实现：要么在全部节点执行，要么在全部节点都不执行。<!--more-->

>分布式事务是指会涉及到多个数据库的事务。这种情况下，一个数据库内部操作是否能提交成功，不仅取决于自身，还与全局中其他事务的成功与否相关。为了保证数据的一致性，要求事务产生统一的结果：即全部提交成功或者全部回滚。

## 2. 数据一致性模型
维护数据副本一致性的代价是很高的，因此，为了满足不同场景的要求，系统采用不同的一致性模型，主要分为以下几种：

### 2.1 强一致性
无论更新哪一个数据副本，都要求随后的读操作能获取到最新的数据，即要求“立即保持一致”。比如2PC。

### 2.2 弱一致性
更新数据副本后，要完成所有数据的一致性，需要等待一段时间，这段时间称之为“不一致性窗口”。

### 2.3 最终一致性
是一种特殊形式的弱一致性。不保证任意时刻任意节点上的同一份数据都是一致的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化，即一段时间后节点间的数据会最终达到一致的状态。
根据不同的保证，最终一致性又可以划分成以下几种模型：
> a)因果一致性：A、B、C三个进程分别独自操作数据，若A更新数据后通知了B，则B在随后的读取中能获取到A更新的数据；但是A没有通知C，因此系统并不一定保证C会获取到A更新的数据值。

> b)读自写一致性：某用户更新数据后，在随后的读取操作中能获取到其更新的值；但系统并不保证其他用户能读取到最新值。

> c)会话一致性：将读自写一致性限定在一个会话的范围内。

> d)单调读一致性：用户读取某个数据值后，在后续的操作中不会读取到该数据更早的版本。

> e)时间轴一致性：也叫单调写一致性，要求数据的所有副本以相同的顺序执行所有的更新操作。 

## 3. 两阶段提交协议（2PC）
对于分布式事务，如果直接提交请求，部分节点执行成功，部分节点失败，则会出现数据的不一致性。
>两阶段提交协议是为了保证分布式事务的数据一致性。为了能够协调并掌握各个节点（称为参与者）的事务执行情况，这里引入一个组件（协调者）。整个2PC分为：准备阶段和提交阶段，准备阶段用于“询问”各个参与者是否能够满足提交，提交阶段则为执行阶段（可能执行提交，也可能执行回滚）

### 3.1 准备阶段
* 协调者向各个参与者发送请求，询问是否可以执行提交，并等待各个参与者的恢复；
* 参与者收到协调者发来的询问请求后，执行事务操作（记录redo和undo），但注意此时还并未提交。如果事务操作成功，则参与者向协调者恢复“yes”，否则回复“no”；
* 协调者接收到所有参与者的回复，当然也可能存在请求超时的情况。

### 3.2 提交阶段
* 若所有的参与者都成功执行了事务，切协调者收集到了所有参与者回复的“yes”，则协调者向所有节点发送“commit”请求，要求所有参与者执行提交操作；只要有一个参与者执行失败或者请求超时，则协调者向所有参与者发送“roll back”请求，要去所有参与者执行回滚；
* 所有的参与者执行【提交】或者【回滚并释放所有事务处理过程中占用的锁资源】。完成后，向协调者发送确认信息；协调者收到所有确认消息后，完成事务。

### 3.3 缺陷
1. 同步阻塞：事务提交过程中，所有参与节点都是阻塞的。这就意味着，当有其他第三方节点访问该节点的资源时，将会处于阻塞状态；
2. 单点故障：一旦协调者发生故障，则会导致参与者处于阻塞状态。例如，当协调者在提交阶段宕机了，参与者锁定事务资源并会一直等待协调者的请求，导致无法完成事务操作。尽管可以通过选举策略重新选择一个协调者，但是无法解决参与者阻塞的问题；
3. 数据不一致：由于协调者在发送commit过程中发生故障，或者因为脑裂（局部网络异常，网络分区）导致部分参与者无法接收commit请求，则会使得部分节点收到commit请求并执行，部分节点没收到commit，从而产生数据的不一致性。

## 4. 三阶段提交协议（3PC）
为了解决2PC中的部分问题，3PC做了一些改进，总体来说就是将2PC中的准备阶段一分为二：CanCommit阶段和PreCommit阶段。另外，3PC中还引入了参与者的超时机制。

### 4.1 CanCommit阶段
>a. 协调者向所有参与者发送CanCommit请求，询问是否可以执行事务提交，并等待所有参与者的回复；

>b. 参与者收到请求后，如果判断自身能够完成事务提交，则回复“yes”，否则回复“no”。

### 4.2 PreCommit阶段
根据CanCommit阶段的回复，PreCommit阶段有两种情况：
1、协调者收到所有参与者回复的“yes”
>a. 协调者向所有参与者发送PreCommit请求，并等待回复；

>b. 参与者收到请求后，执行具体的事务操作（记录undo和redo），此时事务还没有提交；

>c. 如果参与者中事务执行成功，则返回ACK确认操作，否则返回错误信息。

2、协调者收到的回复中包含“no”或者请求超时
>a. 协调者向所有参与者发送abort请求；

>b. 参与者收到abort请求，或者参与者超时之后也未收到来自协调者的请求，则中断事务。

### 4.3 DoCommit阶段
根据PreCommit阶段的回复，DoCommit阶段也有两种情况：
1、协调者收到所有参与者的ACK回复
>a. 协调者向所有参与者发送DoCommit请求，并等待回复；

>b. 参与者收到请求后，执行事务的提交操作，执行完成后，向协调者发送ACK确认消息；

>c. 协调者收到所有来自参与者的ACK消息后，完成事务。

2、协调者没有收到参与者的回复，即等待超时；或者协调者收到的消息不是ACK，而是错误消息
>a. 协调者向所有参与者发送abort请求；

>b. 参与者收到abort请求后，根据之前记录的undo和redo日志，执行事务回滚，并在回滚完成后，释放所有在事务中占用的锁资源；

>c. 参与者完成回滚及释放资源后，向协调者发送ACK消息；协调者收到所有参与者回复的消息后，中断事务。

注意：如果参与者在超时等待后，既没有收到DoCommit，也没收到abort请求，则会选择继续进行事务提交。因为目前已经处于第三阶段了，有理由相信成功提交的几率更大。

3PC解决了2PC中的单点故障问题，并减少了阻塞。因为参与者在超时等待后，会自动提交commit操作，而不是一直等待下去。但是3PC也无法解决数据不一致性，例如，当部分参与者收到了abort请求，而另一部分参与者由于网络通信原因没有收到abort请求，自动执行了commit，则会导致数据不一致。

## 5. Paxos算法
Paxos是一种基于消息传递的提高分布式系统容错性的一致性算法。

背景：
>1、参与者（节点）可能会随时宕机或者出现网络分割的情况

>2、消息传递可能会出现延迟、重复、丢失等可能性，但是其不会被损坏、篡改（没有拜占庭将军的问题）

目的：
>在分布式系统中，关于某个数据值达成一致，从而保证分布式系统的数据一致性。

Paxos算法中存在三种角色：提案者（Proposer），接收者（Acceptor），学习者（Learner）。

### 5.1 Proposer生成提案
>Prepare请求：Proposer提出一个编号为M1的提案，发送给大多数Acceptor，等待回应；

如果Acceptor从未批准过任何提案，则返回数据中关于提案可以为空；否则，返回其批准过的提案中编号最大的提案所对应的编号和Value值；
>Accept请求：Proposer接收到了来自半数以上的Acceptor的回复，则其可以生成编号为M1，值为V1的提案了。注意，值V1应该等于所有回复中编号最大的提案对应的value值。如果所有的回复中都无相关[编号，value]数据，则Proposer可自己提出所需要的数据，赋值给V1。


### 5.2 Acceptor接收提案
若Acceptor之前没有批准过任何提案，则可以批准刚接收的编号为M1的提案；否则，Acceptor不得批准编号小于之前已经批准的提案中最大的编号（例如，之前已经批准M11，M12，M13，M13编号最大，则接下来的提案中，如果编号小于M13，则不得批准）

### 5.3 Learner学习提案
一旦某个提案M0，V0被大多数Acceptor批准，则认为该提案被“选定”。对于已经被“选定”的提案，对于所有的Learner而言，其是可见的（即可被获取到的）